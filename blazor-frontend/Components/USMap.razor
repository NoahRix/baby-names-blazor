@using blazor_frontend.Services
@inject AppState AppState
@inject HttpClient Http

<MudPaper Class="pa-4" Style="width: 100%; max-width: 1600px; margin: 0 auto;">
    @if (errorMessage != null)
    {
        <MudAlert Severity="Severity.Error">@errorMessage</MudAlert>
    }
    @if (states == null)
    {
        <p>Loading states...</p>
    }
    else if (states.Length == 0)
    {
        <p>No states found</p>
    }
    <svg viewBox="0 0 950 600" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: auto;">
        @if (states != null)
        {
            @foreach (var state in states)
            {
                <path d="@state.DrawPath"
                      stroke="white"
                      stroke-width="1"
                      fill="@GetFillColor(state)"
                      @onmouseenter="@(() => OnMouseEnter(state))"
                      @onmouseleave="OnMouseLeave"
                      @onclick="@(() => OnClickAsync(state))"
                      style="cursor: pointer;">
                    <title>@state.StateName</title>
                </path>
            }
        }
    </svg>
</MudPaper>

@code {
    private StateInfo[]? states;
    private string? hoveredState;
    private string? errorMessage;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            states = await Http.GetFromJsonAsync<StateInfo[]>("us_states_paths.json");
            if (states == null || states.Length == 0)
            {
                errorMessage = "States array is null or empty";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading states: {ex.Message}";
        }
        AppState.OnChange += StateHasChanged;
    }

    private void OnMouseEnter(StateInfo state)
    {
        hoveredState = state.StateName;
    }

    private void OnMouseLeave()
    {
        hoveredState = null;
    }

    private async Task OnClickAsync(StateInfo state)
    {
        await InvokeAsync(async () =>
        {
            try
            {
                Console.WriteLine($"State clicked: {state.StateName} ({state.StateCode})");
                
                // Fetch min-max years first
                var minMaxResult = await Http.GetFromJsonAsync<MinMaxYearDto>(
                    $"/api/BabyNames/min-max-years-using-state?stateCode={state.StateCode}");

                if (minMaxResult != null)
                {
                    Console.WriteLine($"Setting state with year range: {minMaxResult.MinYear}-{minMaxResult.MaxYear}");
                    
                    // Auto-set to min year when state is selected
                    var commitYear = minMaxResult.MinYear;

                    // Now fetch the other data with the correct parameters
                    // Fetch year-gender counts with minYear and maxYear
                    var yearGenderCountsTask = Http.GetFromJsonAsync<YearGenderCount[]>(
                        $"/api/BabyNames/year-gender-counts?stateCode={state.StateCode}&minYear={minMaxResult.MinYear}&maxYear={minMaxResult.MaxYear}");

                    // Fetch male-female counts with the committed year
                    var maleFemaleCountsTask = Http.GetFromJsonAsync<MaleFemaleCountDto>(
                        $"/api/BabyNames/male-female-counts?stateCode={state.StateCode}&year={commitYear}");

                    // Fetch top popular names with the committed year
                    var topNamesTask = Http.GetFromJsonAsync<TopPopularMaleFemaleNameCounts>(
                        $"/api/BabyNames/top-popular-male-female-name-counts?stateCode={state.StateCode}&year={commitYear}");

                    // Wait for all requests to complete
                    await Task.WhenAll(yearGenderCountsTask, maleFemaleCountsTask, topNamesTask);

                    var yearGenderCounts = await yearGenderCountsTask;
                    var maleFemaleCounts = await maleFemaleCountsTask;
                    var topNames = await topNamesTask;

                    Console.WriteLine($"Year-gender counts loaded: {yearGenderCounts?.Length ?? 0} records");
                    
                    // Update all state at once to trigger only one notification
                    AppState.SetAllStateData(
                        state,
                        minMaxResult.MinYear,
                        minMaxResult.MaxYear,
                        commitYear,
                        yearGenderCounts?.ToList(),
                        maleFemaleCounts?.MaleCount,
                        maleFemaleCounts?.FemaleCount,
                        topNames
                    );
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error fetching state data: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        });
    }

    private string GetFillColor(StateInfo state)
    {
        if (AppState.SelectedState?.StateName == state.StateName)
            return "orange";
        if (hoveredState == state.StateName)
            return "#4CAF50";
        return "#2196F3";
    }

    public void Dispose()
    {
        AppState.OnChange -= StateHasChanged;
    }

    public class MinMaxYearDto
    {
        public int MinYear { get; set; }
        public int MaxYear { get; set; }
    }

    public class MaleFemaleCountDto
    {
        public int MaleCount { get; set; }
        public int FemaleCount { get; set; }
    }
}
